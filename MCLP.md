---


---

<h1 id="mclp-bsgsc">MCLP: BSG+SC</h1>
<blockquote>
<p><a href="https://docs.google.com/document/d/1TRWv4af10Jyh4goY24D_6VWgwhACgEXA5_oy5xT-0Is/edit#">doc</a> ∙ <a href="https://docs.google.com/spreadsheets/d/15AYwB3ZHXsmz7WtOKGfcs_KSLPa9o9C7867i-EdrH1E/edit?usp=sharing">tabla</a></p>
</blockquote>
<h2 id="algorithm">Algorithm</h2>
<p>The following algorithm is used for attempting to reduce the number of bins:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">reduce_bins</span><span class="token punctuation">(</span>bins<span class="token punctuation">)</span><span class="token punctuation">:</span>
   R <span class="token operator">=</span> select_and_remove_bin<span class="token punctuation">(</span>bins<span class="token punctuation">)</span>
   <span class="token keyword">while</span> R <span class="token keyword">is</span> <span class="token operator">not</span> empty<span class="token punctuation">:</span>
      box <span class="token operator">=</span> select_and_remove_box<span class="token punctuation">(</span>R<span class="token punctuation">)</span>
      left_boxes <span class="token operator">=</span> forced_insert<span class="token punctuation">(</span>bins<span class="token punctuation">,</span> box<span class="token punctuation">)</span>
      <span class="token keyword">if</span> left_boxes <span class="token operator">==</span> box<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
      R<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left_boxes<span class="token punctuation">)</span>
   <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre>
<p>The function <code>forced_insert</code> attempts to insert the box in some bin. The insertion is <em>accepted</em> if the left boxes are <em>easier</em> to locate than the original.  If no attempt is accepted, then <code>left_boxes==box</code></p>
<p>For placing a box <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span> in a bin, the BSG-CLP solver is<br>
executed with all the boxes in the bin plus <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>. The box <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>, i.e., only solutions containing <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span> are taking into account. The boxes that the solver could not insert into the container are returned (left boxes).</p>
<h2 id="implementación-de-binpacking-en-python">Implementación de BinPacking en python</h2>
<p>La idea es modular algoritmo e implementar la resolución del bin packing usando <em>python</em> y <em>Jupyter notebooks</em>.<br>
El objetivo es facilitar la edición, modificación y pruebas de este módulo.</p>
<p>A grandes rasgos el algoritmo hace los siguiente:</p>
<ol>
<li>Generación de bins iniciales usando <strong>BSG</strong></li>
<li>Selección de bin a desarmar y almacenar cajas en <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span></li>
<li>Mientras <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span> no quede vacío o máximo de iteraciones:<br>
a. Seleccionar caja <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span> de <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span></span></span></span></span><br>
b. Seleccionar bin de destino <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span></span></span></span></span><br>
c. Usar <strong>BSG</strong> para generar bin <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">B'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> usando cajas <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">B \cup \{c\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">c</span><span class="mclose">}</span></span></span></span></span>, priorizando <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span>. Es posible que <strong>BSG</strong> retorne conjunto de cajas residuales <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span><br>
d. Si <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span> es mejor que <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span>, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span></span></span></span></span> se reemplaza por <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">B'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.751892em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.751892em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span> en el conjunto de bins y <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>←</mo><mi>C</mi><mo>∪</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">C \gets C \cup R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span></li>
<li>Volver a 2 (seleccionar otro bin para desarmar)</li>
</ol>
<h2 id="comunicación-con-solver-bsg">Comunicación con solver BSG</h2>
<p>El solver BSG debería realizar dos tareas principales:</p>
<p><strong>Generación de bins iniciales</strong><br>
Se podría implementar un solver básico para MCLP (<code>basicsolver_mclp.cpp</code>). Lo que haría este solver sería:</p>
<ul>
<li>cargar la instancia desde un archivo en el servidor</li>
<li>generar bins sin repetir cajas (como ya lo hace una de las funciones del solver)</li>
<li>retornar por salida estándar la lista de bins generados con los ids de cajas y sus porcentajes de llenado (para ser leído usando <em>python</em>)</li>
</ul>
<p>Los parámetros pueden ser los que tienen relación con la función heurística, la generación de bloques (<code>min_fr</code>, <code>max_blocks</code>), <code>n_beams</code>, y quizás alguno que permita randomizar un poco la generación de bins.</p>
<p><strong>BSG priorizando subconjunto de cajas</strong><br>
Idealmente, el solver puede quedar escuchando instrucciones usando el protocolo TCP.<br>
Si es así, el solver no necesitaría volver a cargar la instancia cada vez que es utilizado.</p>
<p>Para hacerlo, en el main se puede implementar una función <code>listen_instruction()</code>, la cuál se quede escuchando un puerto específico y retorne el string de instrucciones que reciba. <a href="https://www.geeksforgeeks.org/socket-programming-cc/">Aquí</a> puedes ver como implementar un socket en c++ (parte del servidor).</p>
<p>Este string podría tener un formato como este:</p>
<pre><code>generate_bin [lista_id_cajas] [lista_cajas_prioritarias]
</code></pre>
<p>Luego, el string es leído y delegado a la función correspondiente del solver.<br>
Finalmente, el solver debería retornar (por el mismo puerto) una la lista de cajas residuales.</p>
<p>Para enviar instrucciones al servidor por consola:</p>
<pre><code>echo &lt;instruccion&gt; | netcat localhost &lt;puerto&gt;
</code></pre>

